// ====================
// DEPENDENCY RESOLUTION & AUTO-GENERATION
// ====================
const DependencyEngine = {
    patterns: new Map(),

    init() {
        // Subscribe to PatternSystem
        if (typeof PatternSystem !== 'undefined') {
            PatternSystem.onRegister((pattern) => {
                // Only load backend/general patterns into DependencyEngine
                if (pattern.type === 'backend' || pattern.type === 'general') {
                    this.patterns.set(pattern.id, {
                        className: pattern.name,
                        description: pattern.description,
                        keywords: pattern.keywords,
                        generate: pattern.generate
                    });
                }
            });
            console.log('[DependencyEngine] Connected to PatternSystem');
        } else {
            console.warn('[DependencyEngine] PatternSystem not found');
        }
    },

    // loadPatterns() removed - handled by PatternSystem subscription

    /**
     * Analyze code for dependencies
     */
    analyzeCode(code) {
        const dependencies = [];
        
        // Match require statements
        const requireRegex = /require\s*\(\s*['"]([^'"]+)['"]\s*\)/g;
        let match;
        
        while ((match = requireRegex.exec(code)) !== null) {
            const path = match[1];
            if (path.startsWith('./') || path.startsWith('../')) {
                dependencies.push({
                    type: 'require',
                    path: path,
                    isLocal: true
                });
            }
        }
        
        // Match ES6 imports
        const importRegex = /import\s+(?:{\s*[^}]+\s*}|\*\s+as\s+\w+|\w+)\s+from\s+['"]([^'"]+)['"]/g;
        
        while ((match = importRegex.exec(code)) !== null) {
            const path = match[1];
            if (path.startsWith('./') || path.startsWith('../')) {
                dependencies.push({
                    type: 'import',
                    path: path,
                    isLocal: true
                });
            }
        }
        
        return dependencies;
    },

    /**
     * Build dependency graph from artifacts
     */
    buildGraph(artifacts) {
        if (!artifacts) return { nodes: [], edges: [] };
        const nodes = [];
        const edges = [];
        const pathMap = new Map();
        
        // Create nodes
        artifacts.forEach(file => {
            const node = {
                id: this.normalizeId(file.path),
                label: this.getFileName(file.path),
                path: file.path,
                lines: file.lines,
                language: file.language,
                type: this.getNodeType(file.path),
                autoGenerated: file.metadata?.autoGenerated || false
            };
            nodes.push(node);
            pathMap.set(node.id, node);
            pathMap.set(file.path, node);
        });
        
        // Create edges
        artifacts.forEach(file => {
            const deps = this.analyzeCode(file.code);
            const sourceId = this.normalizeId(file.path);
            
            deps.forEach(dep => {
                const targetId = this.resolveDepPath(file.path, dep.path);
                const targetExists = nodes.some(n => n.id === targetId);
                
                edges.push({
                    source: sourceId,
                    target: targetId,
                    exists: targetExists,
                    type: dep.type
                });
            });
        });
        
        return { nodes, edges };
    },

    /**
     * Find missing dependencies
     */
    findMissing(graph) {
        const missing = [];
        const seen = new Set();
        
        graph.edges.forEach(edge => {
            if (!edge.exists && !seen.has(edge.target)) {
                seen.add(edge.target);
                
                // CHECK: Skip if already in artifacts
                const alreadyGenerated = graph.nodes.some(n => 
                    n.id.includes(edge.target) || 
                    edge.target.includes(n.id)
                );
                
                if (alreadyGenerated) {
                    return; // Skip this one
                }
                
                const sourceNode = graph.nodes.find(n => n.id === edge.source);
                const pattern = this.identifyPattern(edge.target);
                
                missing.push({
                    requiredBy: sourceNode?.path || edge.source,
                    missingId: edge.target,
                    pattern: pattern,
                    canGenerate: !!pattern
                });
            }
        });
        
        return missing;
    },

    /**
     * Identify pattern from path/filename
     */
    identifyPattern(pathOrId) {
        const normalized = pathOrId.toLowerCase();
        
        for (const [patternName, config] of this.patterns.entries()) {
            // Check if any keyword matches
            if (config.keywords.some(kw => normalized.includes(kw))) {
                return patternName;
            }
            
            // Check class name
            if (normalized.includes(config.className.toLowerCase())) {
                return patternName;
            }
        }
        
        return null;
    },

    /**
     * Auto-generate missing dependencies
     */
    autoGenerate(missing) {
        const generated = [];
        
        missing.forEach(dep => {
            if (!dep.canGenerate || !dep.pattern) {
                // Smart Fallback (Option B)
                const filename = this.getFileName(dep.missingId);
                const className = filename.split('.')[0].split('-').map(p => p.charAt(0).toUpperCase() + p.slice(1)).join('');
                
                generated.push({
                    path: dep.missingId.endsWith('.js') ? dep.missingId : `${dep.missingId}.js`,
                    language: 'javascript',
                    lines: 20,
                    code: `// Auto-generated stub for ${filename}
class ${className} {
    constructor() {
        console.log('${className} initialized');
    }
}
module.exports = new ${className}();`,
                    metadata: { autoGenerated: true, pattern: 'fallback', description: 'Auto-generated stub' }
                });
                return;
            }
            
            const config = this.patterns.get(dep.pattern);
            if (!config) return;
            
            const artifact = config.generate();
            
            // Adjust path to match expected location if needed
            const targetDir = this.getDirectory(dep.requiredBy);
            const expectedPath = this.adjustPath(artifact.path, targetDir, dep.missingId);
            
            generated.push({
                ...artifact,
                path: expectedPath,
                metadata: {
                    ...artifact.metadata,
                    requiredBy: dep.requiredBy,
                    originalPattern: dep.pattern,
                    description: config.description
                }
            });
        });
        
        return generated;
    },

    // Helper methods
    normalizeId(path) {
        return path.replace(/^src\//, '').replace(/\.js$/, '');
    },

    getFileName(path) {
        return path.split('/').pop();
    },

    getDirectory(path) {
        const parts = path.split('/');
        parts.pop();
        return parts.join('/') || 'src';
    },

    getNodeType(path) {
        if (path.includes('server')) return 'server';
        if (path.includes('route') || path.includes('api')) return 'route';
        if (path.includes('controller')) return 'controller';
        if (path.includes('model')) return 'model';
        if (path.includes('middleware')) return 'middleware';
        if (path.includes('handler')) return 'handler';
        return 'module';
    },

    resolveDepPath(fromPath, depPath) {
        // Simple resolution - just normalize the dependency path
        const cleanDep = depPath.replace(/^\.\//, '').replace(/^\.\.\//, '').replace(/\.js$/, '');
        return cleanDep;
    },

    adjustPath(generatedPath, targetDir, missingId) {
        // Try to use the generated path's filename in the target directory
        const filename = this.getFileName(generatedPath);
        return `${targetDir}/${filename}`;
    },

    /**
     * Render dependency graph as SVG
     */
    renderGraph(graph, containerId) {
        const container = document.getElementById(containerId);
        if (!container) {
            console.warn(`[DependencyEngine] Container ${containerId} not found`);
            return;
        }
        
        // Use existing DependencyUtils visualization if available
        if (typeof DependencyUtils !== 'undefined' && DependencyUtils.generateVisualization) {
            const graphData = {};
            graph.nodes.forEach(node => {
                const deps = graph.edges
                    .filter(e => e.source === node.id)
                    .map(e => e.target);
                graphData[node.path] = deps;
            });
            
            const viz = DependencyUtils.generateVisualization(graphData);
            container.innerHTML = this.createSVGFromViz(viz, graph);
        } else {
            // Fallback simple rendering
            container.innerHTML = this.createSimpleGraph(graph);
        }
    },

    createSimpleGraph(graph) {
        return `
            <div style="padding: 1rem; background: var(--bg-secondary); border-radius: 8px;">
                <div style="margin-bottom: 1rem;">
                    <strong>Dependency Graph:</strong> ${graph.nodes.length} files, ${graph.edges.length} dependencies
                </div>
                <div style="display: grid; gap: 0.5rem;">
                    ${graph.nodes.map(node => `
                        <div style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; background: var(--bg-tertiary); border-radius: 4px;">
                            <div style="width: 8px; height: 8px; border-radius: 50%; background: ${node.autoGenerated ? 'var(--accent-green)' : 'var(--accent-blue)'}"></div>
                            <div style="flex: 1;">
                                <div style="font-family: monospace; font-size: 0.9rem;">${node.label}</div>
                                <div style="font-size: 0.75rem; color: var(--text-secondary);">${node.type} â€¢ ${node.lines} lines</div>
                            </div>
                        </div>
                    `).join('')}
                </div>
                <div style="margin-top: 1rem; display: flex; gap: 1rem; font-size: 0.85rem; color: var(--text-secondary);">
                    <div style="display: flex; align-items: center; gap: 0.25rem;">
                        <div style="width: 8px; height: 8px; border-radius: 50%; background: var(--accent-blue)"></div>
                        Generated
                    </div>
                    <div style="display: flex; align-items: center; gap: 0.25rem;">
                        <div style="width: 8px; height: 8px; border-radius: 50%; background: var(--accent-green)"></div>
                        Auto-generated
                    </div>
                </div>
            </div>
        `;
    },

    createSVGFromViz(viz, graph) {
        // Enhanced SVG rendering using viz data
        let svg = '<svg width="100%" height="400" style="background: var(--bg-primary)">';
        
        // Draw edges
        viz.edges.forEach(edge => {
            const sourceNode = viz.nodes.find(n => n.id === edge.source);
            const targetNode = viz.nodes.find(n => n.id === edge.target);
            
            if (sourceNode && targetNode) {
                const edgeData = graph.edges.find(e => 
                    e.source === this.normalizeId(edge.source) && 
                    e.target === this.normalizeId(edge.target)
                );
                
                const strokeColor = edgeData?.exists ? 'var(--border-color)' : 'var(--accent-red)';
                const strokeDash = edgeData?.exists ? '0' : '5,5';
                
                svg += `<line x1="${sourceNode.x}" y1="${sourceNode.y}" x2="${targetNode.x}" y2="${targetNode.y}" stroke="${strokeColor}" stroke-width="2" stroke-dasharray="${strokeDash}"/>`;
            }
        });
        
        // Draw nodes
        viz.nodes.forEach(node => {
            const nodeData = graph.nodes.find(n => n.id === this.normalizeId(node.id));
            const color = nodeData?.autoGenerated ? 'var(--accent-green)' : 'var(--accent-blue)';
            
            svg += `
                <circle cx="${node.x}" cy="${node.y}" r="40" fill="${color}" opacity="0.2" stroke="${color}" stroke-width="2"/>
                <text x="${node.x}" y="${node.y + 55}" text-anchor="middle" fill="var(--text-primary)" font-size="12">${node.label}</text>
            `;
        });
        
        svg += '</svg>';
        return svg;
    }
};

// Expose to window
if (typeof window !== 'undefined') {
    window.DependencyEngine = DependencyEngine;
}

// Initialize on load
if (typeof window !== 'undefined') {
    window.addEventListener('DOMContentLoaded', () => {
        DependencyEngine.init();
    });
}