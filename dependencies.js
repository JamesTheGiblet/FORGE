// ====================
// DEPENDENCY RESOLUTION & AUTO-GENERATION
// ====================
const DependencyEngine = {
    patterns: new Map(),

    init() {
        this.loadPatterns();
        console.log('[DependencyEngine] Initialized with', this.patterns.size, 'patterns');
    },

    loadPatterns() {
        // Rate Limiter Pattern
        this.patterns.set('rate-limiter', {
            className: 'RateLimiter',
            description: 'Token bucket rate limiting',
            keywords: ['rate', 'limit', 'throttle', 'ratelimit'],
            generate: () => ({
                path: 'src/middleware/rate-limiter.js',
                language: 'javascript',
                lines: 67,
                code: `// Auto-generated Rate Limiter
class RateLimiter {
    constructor(config = {}) {
        this.messages = config.messages || 100;
        this.window = config.window || 60000; // ms
        this.clients = new Map();
        
        // Cleanup old entries periodically
        this.cleanupTimer = setInterval(() => this.cleanup(), 60000);
    }
    
    /**
     * Check if client is within rate limit
     * @param {string} clientId - Unique client identifier
     * @returns {boolean} true if allowed, false if rate limited
     */
    check(clientId) {
        const now = Date.now();
        const client = this.clients.get(clientId);
        
        if (!client) {
            this.clients.set(clientId, {
                count: 1,
                resetAt: now + this.window
            });
            return true;
        }
        
        // Reset if window expired
        if (now >= client.resetAt) {
            client.count = 1;
            client.resetAt = now + this.window;
            return true;
        }
        
        // Check limit
        if (client.count >= this.messages) {
            return false;
        }
        
        client.count++;
        return true;
    }
    
    /**
     * Get remaining requests for a client
     */
    getRemaining(clientId) {
        const client = this.clients.get(clientId);
        if (!client) return this.messages;
        
        const now = Date.now();
        if (now >= client.resetAt) return this.messages;
        
        return Math.max(0, this.messages - client.count);
    }
    
    /**
     * Reset rate limit for specific client
     */
    reset(clientId) {
        this.clients.delete(clientId);
    }
    
    /**
     * Cleanup expired entries
     */
    cleanup() {
        const now = Date.now();
        this.clients.forEach((client, id) => {
            if (now >= client.resetAt) {
                this.clients.delete(id);
            }
        });
    }
    
    /**
     * Destroy and cleanup
     */
    destroy() {
        if (this.cleanupTimer) {
            clearInterval(this.cleanupTimer);
        }
        this.clients.clear();
    }
}

module.exports = RateLimiter;`,
                metadata: { autoGenerated: true, pattern: 'rate-limiter' }
            })
        });

        // Message Handler Pattern
        this.patterns.set('message-handler', {
            className: 'MessageHandler',
            description: 'Extensible message routing',
            keywords: ['message', 'handler', 'router', 'dispatch'],
            generate: () => ({
                path: 'src/handlers/message-handler.js',
                language: 'javascript',
                lines: 72,
                code: `// Auto-generated Message Handler
class MessageHandler {
    constructor() {
        this.handlers = new Map();
        this.middleware = [];
        this.registerDefaultHandlers();
    }
    
    /**
     * Register default handlers
     */
    registerDefaultHandlers() {
        // Ping/pong
        this.register('ping', async (message, client) => {
            return { 
                type: 'pong', 
                timestamp: Date.now(),
                latency: Date.now() - (message.timestamp || Date.now())
            };
        });
        
        // Echo for debugging
        this.register('echo', async (message, client) => {
            return { 
                type: 'echo', 
                data: message.data,
                timestamp: Date.now()
            };
        });
    }
    
    /**
     * Register message handler
     * @param {string} type - Message type
     * @param {Function} handler - Handler function
     */
    register(type, handler) {
        if (typeof handler !== 'function') {
            throw new Error(\`Handler for \${type} must be a function\`);
        }
        this.handlers.set(type, handler);
    }
    
    /**
     * Add middleware
     */
    use(fn) {
        this.middleware.push(fn);
    }
    
    /**
     * Handle incoming message
     */
    async handle(message, client) {
        if (!message?.type) {
            throw new Error('Message type required');
        }
        
        // Run middleware
        for (const mw of this.middleware) {
            const shouldContinue = await mw(message, client);
            if (shouldContinue === false) return null;
        }
        
        // Find and execute handler
        const handler = this.handlers.get(message.type);
        if (!handler) {
            throw new Error(\`Unknown message type: \${message.type}\`);
        }
        
        return await handler(message, client);
    }
    
    /**
     * Get registered types
     */
    getRegisteredTypes() {
        return Array.from(this.handlers.keys());
    }
}

module.exports = MessageHandler;`,
                metadata: { autoGenerated: true, pattern: 'message-handler' }
            })
        });

        // Database Connection Pattern
        this.patterns.set('database', {
            className: 'Database',
            description: 'Database connection pool',
            keywords: ['database', 'db', 'connection', 'pool', 'postgres', 'mysql'],
            generate: () => ({
                path: 'src/database/connection.js',
                language: 'javascript',
                lines: 85,
                code: `// Auto-generated Database Connection
const { Pool } = require('pg'); // Change to mysql2 or mongoose as needed

class Database {
    constructor(config = {}) {
        this.config = {
            host: config.host || process.env.DB_HOST || 'localhost',
            port: config.port || process.env.DB_PORT || 5432,
            database: config.database || process.env.DB_NAME,
            user: config.user || process.env.DB_USER,
            password: config.password || process.env.DB_PASSWORD,
            max: config.max || 20,
            idleTimeoutMillis: config.idleTimeoutMillis || 30000,
            ...config
        };
        
        this.pool = null;
        this.isConnected = false;
    }
    
    async connect() {
        if (this.pool) return;
        
        try {
            this.pool = new Pool(this.config);
            
            // Test connection
            const client = await this.pool.connect();
            await client.query('SELECT NOW()');
            client.release();
            
            this.isConnected = true;
            console.log('[Database] Connected successfully');
            
            this.pool.on('error', (err) => {
                console.error('[Database] Unexpected error:', err);
                this.isConnected = false;
            });
        } catch (error) {
            console.error('[Database] Connection failed:', error);
            throw error;
        }
    }
    
    async query(sql, params = []) {
        if (!this.pool) throw new Error('Database not connected');
        
        try {
            return await this.pool.query(sql, params);
        } catch (error) {
            console.error('[Database] Query error:', error);
            throw error;
        }
    }
    
    async transaction(callback) {
        const client = await this.pool.connect();
        
        try {
            await client.query('BEGIN');
            const result = await callback(client);
            await client.query('COMMIT');
            return result;
        } catch (error) {
            await client.query('ROLLBACK');
            throw error;
        } finally {
            client.release();
        }
    }
    
    async disconnect() {
        if (this.pool) {
            await this.pool.end();
            this.pool = null;
            this.isConnected = false;
            console.log('[Database] Disconnected');
        }
    }
}

module.exports = Database;`,
                metadata: { autoGenerated: true, pattern: 'database' }
            })
        });

        // Validation Middleware Pattern
        this.patterns.set('validator', {
            className: 'Validator',
            description: 'Input validation utilities',
            keywords: ['validat', 'sanitize', 'check', 'verify'],
            generate: () => ({
                path: 'src/middleware/validator.js',
                language: 'javascript',
                lines: 58,
                code: `// Auto-generated Validator
class Validator {
    static required(value, fieldName) {
        if (value === null || value === undefined || value === '') {
            throw new Error(\`\${fieldName} is required\`);
        }
        return value;
    }
    
    static email(value) {
        const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;
        if (!emailRegex.test(value)) {
            throw new Error('Invalid email format');
        }
        return value;
    }
    
    static minLength(value, min, fieldName) {
        if (value.length < min) {
            throw new Error(\`\${fieldName} must be at least \${min} characters\`);
        }
        return value;
    }
    
    static maxLength(value, max, fieldName) {
        if (value.length > max) {
            throw new Error(\`\${fieldName} must be at most \${max} characters\`);
        }
        return value;
    }
    
    static isInteger(value) {
        if (!Number.isInteger(Number(value))) {
            throw new Error('Must be an integer');
        }
        return Number(value);
    }
    
    static inRange(value, min, max) {
        const num = Number(value);
        if (num < min || num > max) {
            throw new Error(\`Must be between \${min} and \${max}\`);
        }
        return num;
    }
    
    static sanitize(value) {
        return String(value)
            .replace(/[<>]/g, '')
            .trim();
    }
    
    static validate(data, schema) {
        const errors = {};
        
        for (const [field, rules] of Object.entries(schema)) {
            try {
                let value = data[field];
                for (const rule of rules) {
                    value = rule(value, field);
                }
            } catch (error) {
                errors[field] = error.message;
            }
        }
        
        if (Object.keys(errors).length > 0) {
            throw { errors };
        }
        
        return data;
    }
}

module.exports = Validator;`,
                metadata: { autoGenerated: true, pattern: 'validator' }
            })
        });
    },

    /**
     * Analyze code for dependencies
     */
    analyzeCode(code) {
        const dependencies = [];
        
        // Match require statements
        const requireRegex = /require\s*\(\s*['"]([^'"]+)['"]\s*\)/g;
        let match;
        
        while ((match = requireRegex.exec(code)) !== null) {
            const path = match[1];
            if (path.startsWith('./') || path.startsWith('../')) {
                dependencies.push({
                    type: 'require',
                    path: path,
                    isLocal: true
                });
            }
        }
        
        // Match ES6 imports
        const importRegex = /import\s+(?:{\s*[^}]+\s*}|\*\s+as\s+\w+|\w+)\s+from\s+['"]([^'"]+)['"]/g;
        
        while ((match = importRegex.exec(code)) !== null) {
            const path = match[1];
            if (path.startsWith('./') || path.startsWith('../')) {
                dependencies.push({
                    type: 'import',
                    path: path,
                    isLocal: true
                });
            }
        }
        
        return dependencies;
    },

    /**
     * Build dependency graph from artifacts
     */
    buildGraph(artifacts) {
        const nodes = [];
        const edges = [];
        const pathMap = new Map();
        
        // Create nodes
        artifacts.forEach(file => {
            const node = {
                id: this.normalizeId(file.path),
                label: this.getFileName(file.path),
                path: file.path,
                lines: file.lines,
                language: file.language,
                type: this.getNodeType(file.path),
                autoGenerated: file.metadata?.autoGenerated || false
            };
            nodes.push(node);
            pathMap.set(node.id, node);
            pathMap.set(file.path, node);
        });
        
        // Create edges
        artifacts.forEach(file => {
            const deps = this.analyzeCode(file.code);
            const sourceId = this.normalizeId(file.path);
            
            deps.forEach(dep => {
                const targetId = this.resolveDepPath(file.path, dep.path);
                const targetExists = nodes.some(n => n.id === targetId);
                
                edges.push({
                    source: sourceId,
                    target: targetId,
                    exists: targetExists,
                    type: dep.type
                });
            });
        });
        
        return { nodes, edges };
    },

    /**
     * Find missing dependencies
     */
    findMissing(graph) {
        const missing = [];
        const seen = new Set();
        
        graph.edges.forEach(edge => {
            if (!edge.exists && !seen.has(edge.target)) {
                seen.add(edge.target);
                
                const sourceNode = graph.nodes.find(n => n.id === edge.source);
                const pattern = this.identifyPattern(edge.target);
                
                missing.push({
                    requiredBy: sourceNode?.path || edge.source,
                    missingId: edge.target,
                    pattern: pattern,
                    canGenerate: !!pattern
                });
            }
        });
        
        return missing;
    },

    /**
     * Identify pattern from path/filename
     */
    identifyPattern(pathOrId) {
        const normalized = pathOrId.toLowerCase();
        
        for (const [patternName, config] of this.patterns.entries()) {
            // Check if any keyword matches
            if (config.keywords.some(kw => normalized.includes(kw))) {
                return patternName;
            }
            
            // Check class name
            if (normalized.includes(config.className.toLowerCase())) {
                return patternName;
            }
        }
        
        return null;
    },

    /**
     * Auto-generate missing dependencies
     */
    autoGenerate(missing) {
        const generated = [];
        
        missing.forEach(dep => {
            if (!dep.canGenerate || !dep.pattern) {
                console.warn(`[DependencyEngine] Cannot auto-generate: ${dep.missingId}`);
                return;
            }
            
            const config = this.patterns.get(dep.pattern);
            if (!config) return;
            
            const artifact = config.generate();
            
            // Adjust path to match expected location if needed
            const targetDir = this.getDirectory(dep.requiredBy);
            const expectedPath = this.adjustPath(artifact.path, targetDir, dep.missingId);
            
            generated.push({
                ...artifact,
                path: expectedPath,
                metadata: {
                    ...artifact.metadata,
                    requiredBy: dep.requiredBy,
                    originalPattern: dep.pattern,
                    description: config.description
                }
            });
        });
        
        return generated;
    },

    // Helper methods
    normalizeId(path) {
        return path.replace(/^src\//, '').replace(/\.js$/, '');
    },

    getFileName(path) {
        return path.split('/').pop();
    },

    getDirectory(path) {
        const parts = path.split('/');
        parts.pop();
        return parts.join('/') || 'src';
    },

    getNodeType(path) {
        if (path.includes('server')) return 'server';
        if (path.includes('route') || path.includes('api')) return 'route';
        if (path.includes('controller')) return 'controller';
        if (path.includes('model')) return 'model';
        if (path.includes('middleware')) return 'middleware';
        if (path.includes('handler')) return 'handler';
        return 'module';
    },

    resolveDepPath(fromPath, depPath) {
        // Simple resolution - just normalize the dependency path
        const cleanDep = depPath.replace(/^\.\//, '').replace(/^\.\.\//, '').replace(/\.js$/, '');
        return cleanDep;
    },

    adjustPath(generatedPath, targetDir, missingId) {
        // Try to use the generated path's filename in the target directory
        const filename = this.getFileName(generatedPath);
        return `${targetDir}/${filename}`;
    },

    /**
     * Render dependency graph as SVG
     */
    renderGraph(graph, containerId) {
        const container = document.getElementById(containerId);
        if (!container) {
            console.warn(`[DependencyEngine] Container ${containerId} not found`);
            return;
        }
        
        // Use existing DependencyUtils visualization if available
        if (typeof DependencyUtils !== 'undefined' && DependencyUtils.generateVisualization) {
            const graphData = {};
            graph.nodes.forEach(node => {
                const deps = graph.edges
                    .filter(e => e.source === node.id)
                    .map(e => e.target);
                graphData[node.path] = deps;
            });
            
            const viz = DependencyUtils.generateVisualization(graphData);
            container.innerHTML = this.createSVGFromViz(viz, graph);
        } else {
            // Fallback simple rendering
            container.innerHTML = this.createSimpleGraph(graph);
        }
    },

    createSimpleGraph(graph) {
        return `
            <div style="padding: 1rem; background: var(--bg-secondary); border-radius: 8px;">
                <div style="margin-bottom: 1rem;">
                    <strong>Dependency Graph:</strong> ${graph.nodes.length} files, ${graph.edges.length} dependencies
                </div>
                <div style="display: grid; gap: 0.5rem;">
                    ${graph.nodes.map(node => `
                        <div style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; background: var(--bg-tertiary); border-radius: 4px;">
                            <div style="width: 8px; height: 8px; border-radius: 50%; background: ${node.autoGenerated ? 'var(--accent-green)' : 'var(--accent-blue)'}"></div>
                            <div style="flex: 1;">
                                <div style="font-family: monospace; font-size: 0.9rem;">${node.label}</div>
                                <div style="font-size: 0.75rem; color: var(--text-secondary);">${node.type} â€¢ ${node.lines} lines</div>
                            </div>
                        </div>
                    `).join('')}
                </div>
                <div style="margin-top: 1rem; display: flex; gap: 1rem; font-size: 0.85rem; color: var(--text-secondary);">
                    <div style="display: flex; align-items: center; gap: 0.25rem;">
                        <div style="width: 8px; height: 8px; border-radius: 50%; background: var(--accent-blue)"></div>
                        Generated
                    </div>
                    <div style="display: flex; align-items: center; gap: 0.25rem;">
                        <div style="width: 8px; height: 8px; border-radius: 50%; background: var(--accent-green)"></div>
                        Auto-generated
                    </div>
                </div>
            </div>
        `;
    },

    createSVGFromViz(viz, graph) {
        // Enhanced SVG rendering using viz data
        let svg = '<svg width="100%" height="400" style="background: var(--bg-primary)">';
        
        // Draw edges
        viz.edges.forEach(edge => {
            const sourceNode = viz.nodes.find(n => n.id === edge.source);
            const targetNode = viz.nodes.find(n => n.id === edge.target);
            
            if (sourceNode && targetNode) {
                const edgeData = graph.edges.find(e => 
                    e.source === this.normalizeId(edge.source) && 
                    e.target === this.normalizeId(edge.target)
                );
                
                const strokeColor = edgeData?.exists ? 'var(--border-color)' : 'var(--accent-red)';
                const strokeDash = edgeData?.exists ? '0' : '5,5';
                
                svg += `<line x1="${sourceNode.x}" y1="${sourceNode.y}" x2="${targetNode.x}" y2="${targetNode.y}" stroke="${strokeColor}" stroke-width="2" stroke-dasharray="${strokeDash}"/>`;
            }
        });
        
        // Draw nodes
        viz.nodes.forEach(node => {
            const nodeData = graph.nodes.find(n => n.id === this.normalizeId(node.id));
            const color = nodeData?.autoGenerated ? 'var(--accent-green)' : 'var(--accent-blue)';
            
            svg += `
                <circle cx="${node.x}" cy="${node.y}" r="40" fill="${color}" opacity="0.2" stroke="${color}" stroke-width="2"/>
                <text x="${node.x}" y="${node.y + 55}" text-anchor="middle" fill="var(--text-primary)" font-size="12">${node.label}</text>
            `;
        });
        
        svg += '</svg>';
        return svg;
    }
};

// Initialize on load
if (typeof window !== 'undefined') {
    window.addEventListener('DOMContentLoaded', () => {
        DependencyEngine.init();
    });
}