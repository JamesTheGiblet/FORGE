// ====================
// DEPENDENCY RESOLUTION & AUTO-GENERATION
// ====================
const DependencyEngine = {
    patterns: new Map(),

    init() {
        this.loadPatterns();
        console.log('[DependencyEngine] Initialized with', this.patterns.size, 'patterns');
    },

    loadPatterns() {
        // Rate Limiter Pattern
        this.patterns.set('rate-limiter', {
            className: 'RateLimiter',
            description: 'Token bucket rate limiting',
            keywords: ['rate', 'limit', 'throttle', 'ratelimit'],
            generate: () => ({
                path: 'src/middleware/rate-limiter.js',
                language: 'javascript',
                lines: 67,
                code: `// Auto-generated Rate Limiter
class RateLimiter {
    constructor(config = {}) {
        this.messages = config.messages || 100;
        this.window = config.window || 60000; // ms
        this.clients = new Map();
        
        // Cleanup old entries periodically
        this.cleanupTimer = setInterval(() => this.cleanup(), 60000);
    }
    
    /**
     * Check if client is within rate limit
     * @param {string} clientId - Unique client identifier
     * @returns {boolean} true if allowed, false if rate limited
     */
    check(clientId) {
        const now = Date.now();
        const client = this.clients.get(clientId);
        
        if (!client) {
            this.clients.set(clientId, {
                count: 1,
                resetAt: now + this.window
            });
            return true;
        }
        
        // Reset if window expired
        if (now >= client.resetAt) {
            client.count = 1;
            client.resetAt = now + this.window;
            return true;
        }
        
        // Check limit
        if (client.count >= this.messages) {
            return false;
        }
        
        client.count++;
        return true;
    }
    
    /**
     * Get remaining requests for a client
     */
    getRemaining(clientId) {
        const client = this.clients.get(clientId);
        if (!client) return this.messages;
        
        const now = Date.now();
        if (now >= client.resetAt) return this.messages;
        
        return Math.max(0, this.messages - client.count);
    }
    
    /**
     * Reset rate limit for specific client
     */
    reset(clientId) {
        this.clients.delete(clientId);
    }
    
    /**
     * Cleanup expired entries
     */
    cleanup() {
        const now = Date.now();
        this.clients.forEach((client, id) => {
            if (now >= client.resetAt) {
                this.clients.delete(id);
            }
        });
    }
    
    /**
     * Destroy and cleanup
     */
    destroy() {
        if (this.cleanupTimer) {
            clearInterval(this.cleanupTimer);
        }
        this.clients.clear();
    }
}

module.exports = RateLimiter;`,
                metadata: { autoGenerated: true, pattern: 'rate-limiter' }
            })
        });

        // Message Handler Pattern
        this.patterns.set('message-handler', {
            className: 'MessageHandler',
            description: 'Extensible message routing',
            keywords: ['message', 'handler', 'router', 'dispatch'],
            generate: () => ({
                path: 'src/handlers/message-handler.js',
                language: 'javascript',
                lines: 72,
                code: `// Auto-generated Message Handler
class MessageHandler {
    constructor() {
        this.handlers = new Map();
        this.middleware = [];
        this.registerDefaultHandlers();
    }
    
    /**
     * Register default handlers
     */
    registerDefaultHandlers() {
        // Ping/pong
        this.register('ping', async (message, client) => {
            return { 
                type: 'pong', 
                timestamp: Date.now(),
                latency: Date.now() - (message.timestamp || Date.now())
            };
        });
        
        // Echo for debugging
        this.register('echo', async (message, client) => {
            return { 
                type: 'echo', 
                data: message.data,
                timestamp: Date.now()
            };
        });
    }
    
    /**
     * Register message handler
     * @param {string} type - Message type
     * @param {Function} handler - Handler function
     */
    register(type, handler) {
        if (typeof handler !== 'function') {
            throw new Error(\`Handler for \${type} must be a function\`);
        }
        this.handlers.set(type, handler);
    }
    
    /**
     * Add middleware
     */
    use(fn) {
        this.middleware.push(fn);
    }
    
    /**
     * Handle incoming message
     */
    async handle(message, client) {
        if (!message?.type) {
            throw new Error('Message type required');
        }
        
        // Run middleware
        for (const mw of this.middleware) {
            const shouldContinue = await mw(message, client);
            if (shouldContinue === false) return null;
        }
        
        // Find and execute handler
        const handler = this.handlers.get(message.type);
        if (!handler) {
            throw new Error(\`Unknown message type: \${message.type}\`);
        }
        
        return await handler(message, client);
    }
    
    /**
     * Get registered types
     */
    getRegisteredTypes() {
        return Array.from(this.handlers.keys());
    }
}

module.exports = MessageHandler;`,
                metadata: { autoGenerated: true, pattern: 'message-handler' }
            })
        });

        // Database Connection Pattern
        this.patterns.set('database', {
            className: 'Database',
            description: 'Database connection pool',
            keywords: ['database', 'db', 'connection', 'pool', 'postgres', 'mysql'],
            generate: () => ({
                path: 'src/database/connection.js',
                language: 'javascript',
                lines: 85,
                code: `// Auto-generated Database Connection
const { Pool } = require('pg'); // Change to mysql2 or mongoose as needed

class Database {
    constructor(config = {}) {
        this.config = {
            host: config.host || process.env.DB_HOST || 'localhost',
            port: config.port || process.env.DB_PORT || 5432,
            database: config.database || process.env.DB_NAME,
            user: config.user || process.env.DB_USER,
            password: config.password || process.env.DB_PASSWORD,
            max: config.max || 20,
            idleTimeoutMillis: config.idleTimeoutMillis || 30000,
            ...config
        };
        
        this.pool = null;
        this.isConnected = false;
    }
    
    async connect() {
        if (this.pool) return;
        
        try {
            this.pool = new Pool(this.config);
            
            // Test connection
            const client = await this.pool.connect();
            await client.query('SELECT NOW()');
            client.release();
            
            this.isConnected = true;
            console.log('[Database] Connected successfully');
            
            this.pool.on('error', (err) => {
                console.error('[Database] Unexpected error:', err);
                this.isConnected = false;
            });
        } catch (error) {
            console.error('[Database] Connection failed:', error);
            throw error;
        }
    }
    
    async query(sql, params = []) {
        if (!this.pool) throw new Error('Database not connected');
        
        try {
            return await this.pool.query(sql, params);
        } catch (error) {
            console.error('[Database] Query error:', error);
            throw error;
        }
    }
    
    async transaction(callback) {
        const client = await this.pool.connect();
        
        try {
            await client.query('BEGIN');
            const result = await callback(client);
            await client.query('COMMIT');
            return result;
        } catch (error) {
            await client.query('ROLLBACK');
            throw error;
        } finally {
            client.release();
        }
    }
    
    async disconnect() {
        if (this.pool) {
            await this.pool.end();
            this.pool = null;
            this.isConnected = false;
            console.log('[Database] Disconnected');
        }
    }
}

module.exports = Database;`,
                metadata: { autoGenerated: true, pattern: 'database' }
            })
        });

        // Validation Middleware Pattern
        this.patterns.set('validator', {
            className: 'Validator',
            description: 'Input validation utilities',
            keywords: ['validat', 'sanitize', 'check', 'verify'],
            generate: () => ({
                path: 'src/middleware/validator.js',
                language: 'javascript',
                lines: 58,
                code: `// Auto-generated Validator
class Validator {
    static required(value, fieldName) {
        if (value === null || value === undefined || value === '') {
            throw new Error(\`\${fieldName} is required\`);
        }
        return value;
    }
    
    static email(value) {
        const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;
        if (!emailRegex.test(value)) {
            throw new Error('Invalid email format');
        }
        return value;
    }
    
    static minLength(value, min, fieldName) {
        if (value.length < min) {
            throw new Error(\`\${fieldName} must be at least \${min} characters\`);
        }
        return value;
    }
    
    static maxLength(value, max, fieldName) {
        if (value.length > max) {
            throw new Error(\`\${fieldName} must be at most \${max} characters\`);
        }
        return value;
    }
    
    static isInteger(value) {
        if (!Number.isInteger(Number(value))) {
            throw new Error('Must be an integer');
        }
        return Number(value);
    }
    
    static inRange(value, min, max) {
        const num = Number(value);
        if (num < min || num > max) {
            throw new Error(\`Must be between \${min} and \${max}\`);
        }
        return num;
    }
    
    static sanitize(value) {
        return String(value)
            .replace(/[<>]/g, '')
            .trim();
    }
    
    static validate(data, schema) {
        const errors = {};
        
        for (const [field, rules] of Object.entries(schema)) {
            try {
                let value = data[field];
                for (const rule of rules) {
                    value = rule(value, field);
                }
            } catch (error) {
                errors[field] = error.message;
            }
        }
        
        if (Object.keys(errors).length > 0) {
            throw { errors };
        }
        
        return data;
    }
}

module.exports = Validator;`,
                metadata: { autoGenerated: true, pattern: 'validator' }
            })
        });

        // Model Pattern
        this.patterns.set('model', {
            className: 'Model',
            description: 'Mongoose data model schema',
            keywords: ['model', 'schema', 'entity', 'mongoose'],
            generate: () => ({
                path: 'src/models/User.js',
                language: 'javascript',
                lines: 65,
                code: `// Mongoose User Model
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');

const UserSchema = new mongoose.Schema({
    name: {
        type: String,
        required: [true, 'Please add a name'],
        trim: true,
        maxlength: [50, 'Name can not be more than 50 characters']
    },
    email: {
        type: String,
        required: [true, 'Please add an email'],
        unique: true,
        match: [
            /^\\w+([\\.-]?\\w+)*@\\w+([\\.-]?\\w+)*(\\.\\w{2,3})+$/,
            'Please add a valid email'
        ]
    },
    role: {
        type: String,
        enum: ['user', 'admin'],
        default: 'user'
    },
    password: {
        type: String,
        required: [true, 'Please add a password'],
        minlength: 6,
        select: false
    },
    resetPasswordToken: String,
    resetPasswordExpire: Date,
    createdAt: {
        type: Date,
        default: Date.now
    }
});

// Encrypt password using bcrypt
UserSchema.pre('save', async function(next) {
    if (!this.isModified('password')) {
        next();
    }
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
});

// Sign JWT and return
UserSchema.methods.getSignedJwtToken = function() {
    return jwt.sign({ id: this._id }, process.env.JWT_SECRET, {
        expiresIn: process.env.JWT_EXPIRE || '30d'
    });
};

// Match user entered password to hashed password in database
UserSchema.methods.matchPassword = async function(enteredPassword) {
    return await bcrypt.compare(enteredPassword, this.password);
};

module.exports = mongoose.model('User', UserSchema);`,
                metadata: { autoGenerated: true, pattern: 'model' }
            })
        });

        // Postgres Pattern
        this.patterns.set('postgres', {
            className: 'PostgresDB',
            description: 'PostgreSQL connection wrapper',
            keywords: ['postgres', 'pg', 'postgresql'],
            generate: () => ({
                path: 'src/lib/postgres.js',
                language: 'javascript',
                lines: 45,
                code: `// PostgreSQL Client
const { Pool } = require('pg');

const pool = new Pool({
    connectionString: process.env.DATABASE_URL,
    ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
});

module.exports = {
    query: (text, params) => pool.query(text, params),
    getClient: () => pool.connect(),
    pool
};`,
                metadata: { autoGenerated: true, pattern: 'postgres' }
            })
        });

        // Controller Pattern
        this.patterns.set('controller', {
            className: 'Controller',
            description: 'REST API controller with CRUD operations',
            keywords: ['controller', 'ctrl'],
            generate: () => ({
                path: 'src/controllers/base.controller.js',
                language: 'javascript',
                lines: 120,
                code: `// Base REST Controller
class BaseController {
    constructor(model) {
        this.model = model;
    }

    /**
     * Get all documents
     * @route GET /api/v1/resources
     */
    getAll = async (req, res, next) => {
        try {
            const page = parseInt(req.query.page, 10) || 1;
            const limit = parseInt(req.query.limit, 10) || 25;
            const startIndex = (page - 1) * limit;
            const endIndex = page * limit;
            const total = await this.model.countDocuments();

            const query = this.model.find().skip(startIndex).limit(limit);
            
            // Execute query
            const results = await query;

            // Pagination result
            const pagination = {};
            if (endIndex < total) {
                pagination.next = { page: page + 1, limit };
            }
            if (startIndex > 0) {
                pagination.prev = { page: page - 1, limit };
            }

            res.status(200).json({
                success: true,
                count: results.length,
                pagination,
                data: results
            });
        } catch (error) {
            next(error);
        }
    };

    /**
     * Get single document
     * @route GET /api/v1/resources/:id
     */
    getOne = async (req, res, next) => {
        try {
            const doc = await this.model.findById(req.params.id);
            if (!doc) {
                return res.status(404).json({
                    success: false,
                    error: 'Resource not found'
                });
            }
            res.status(200).json({
                success: true,
                data: doc
            });
        } catch (error) {
            next(error);
        }
    };

    /**
     * Create document
     * @route POST /api/v1/resources
     */
    create = async (req, res, next) => {
        try {
            const doc = await this.model.create(req.body);
            res.status(201).json({
                success: true,
                data: doc
            });
        } catch (error) {
            next(error);
        }
    };

    /**
     * Update document
     * @route PUT /api/v1/resources/:id
     */
    update = async (req, res, next) => {
        try {
            const doc = await this.model.findByIdAndUpdate(req.params.id, req.body, {
                new: true,
                runValidators: true
            });

            if (!doc) {
                return res.status(404).json({
                    success: false,
                    error: 'Resource not found'
                });
            }

            res.status(200).json({
                success: true,
                data: doc
            });
        } catch (error) {
            next(error);
        }
    };

    /**
     * Delete document
     * @route DELETE /api/v1/resources/:id
     */
    delete = async (req, res, next) => {
        try {
            const doc = await this.model.findByIdAndDelete(req.params.id);

            if (!doc) {
                return res.status(404).json({
                    success: false,
                    error: 'Resource not found'
                });
            }

            res.status(200).json({
                success: true,
                data: {}
            });
        } catch (error) {
            next(error);
        }
    };
}

module.exports = BaseController;`,
                metadata: { autoGenerated: true, pattern: 'controller' }
            })
        });

        // Validation Pattern
        this.patterns.set('validation', {
            className: 'Validation',
            description: 'Comprehensive validation utilities',
            keywords: ['validation', 'joi', 'schema', 'rules'],
            generate: () => ({
                path: 'src/utils/validation.js',
                language: 'javascript',
                lines: 85,
                code: `// Validation Utilities
class Validation {
    /**
     * Validate email format
     */
    static isEmail(email) {
        const re = /^(([^<>()[\\]\\\\.,;:\\s@"]+(\\.[^<>()[\\]\\\\.,;:\\s@"]+)*)|(".+"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;
        return re.test(String(email).toLowerCase());
    }

    /**
     * Validate password strength
     * Min 8 chars, 1 uppercase, 1 lowercase, 1 number, 1 special char
     */
    static isStrongPassword(password) {
        const strongPasswordRegex = new RegExp("^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#\\$%\\^&\\*])(?=.{8,})");
        return strongPasswordRegex.test(password);
    }

    /**
     * Validate required fields
     */
    static validateRequired(data, fields) {
        const errors = [];
        fields.forEach(field => {
            if (!data[field] || data[field].trim() === '') {
                errors.push(\`\${field} is required\`);
            }
        });
        return errors;
    }

    /**
     * Sanitize input to prevent XSS
     */
    static sanitize(input) {
        if (typeof input !== 'string') return input;
        return input.replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }

    /**
     * Validate object against schema
     */
    static validateSchema(data, schema) {
        const errors = {};
        
        Object.keys(schema).forEach(field => {
            const rules = schema[field];
            const value = data[field];

            if (rules.required && !value) {
                errors[field] = 'Required';
                return;
            }

            if (value) {
                if (rules.type && typeof value !== rules.type) {
                    errors[field] = \`Must be type \${rules.type}\`;
                }
                if (rules.min && value.length < rules.min) {
                    errors[field] = \`Min length is \${rules.min}\`;
                }
                if (rules.max && value.length > rules.max) {
                    errors[field] = \`Max length is \${rules.max}\`;
                }
                if (rules.pattern && !rules.pattern.test(value)) {
                    errors[field] = 'Invalid format';
                }
            }
        });

        return {
            isValid: Object.keys(errors).length === 0,
            errors
        };
    }
}

module.exports = Validation;`,
                metadata: { autoGenerated: true, pattern: 'validation' }
            })
        });

        // Redis Pattern
        this.patterns.set('redis', {
            className: 'RedisClient',
            description: 'Redis cache connection wrapper',
            keywords: ['redis', 'cache', 'store', 'caching'],
            generate: () => ({
                path: 'src/config/redis.js',
                language: 'javascript',
                lines: 55,
                code: `// Redis Client Wrapper
const Redis = require('ioredis');

class RedisClient {
    constructor() {
        this.client = null;
        this.isConnected = false;
    }

    connect() {
        if (this.client) return;

        this.client = new Redis({
            host: process.env.REDIS_HOST || 'localhost',
            port: process.env.REDIS_PORT || 6379,
            password: process.env.REDIS_PASSWORD,
            retryStrategy: (times) => Math.min(times * 50, 2000)
        });

        this.client.on('connect', () => {
            this.isConnected = true;
            console.log('[Redis] Connected');
        });

        this.client.on('error', (err) => {
            console.error('[Redis] Error:', err);
            this.isConnected = false;
        });
    }

    async get(key) {
        if (!this.client) this.connect();
        const data = await this.client.get(key);
        try {
            return JSON.parse(data);
        } catch {
            return data;
        }
    }

    async set(key, value, ttl = 3600) {
        if (!this.client) this.connect();
        const data = typeof value === 'object' ? JSON.stringify(value) : value;
        if (ttl) {
            await this.client.set(key, data, 'EX', ttl);
        } else {
            await this.client.set(key, data);
        }
    }
    
    async del(key) {
        if (!this.client) this.connect();
        await this.client.del(key);
    }
}

module.exports = new RedisClient();`,
                metadata: { autoGenerated: true, pattern: 'redis' }
            })
        });

        // Queue Pattern
        this.patterns.set('queue', {
            className: 'Queue',
            description: 'Background job queue system',
            keywords: ['queue', 'job', 'worker', 'background'],
            generate: () => ({
                path: 'src/lib/queue.js',
                language: 'javascript',
                lines: 65,
                code: `// Simple In-Memory Job Queue (Replace with Bull/RabbitMQ for production)
const EventEmitter = require('events');

class Queue extends EventEmitter {
    constructor(options = {}) {
        super();
        this.concurrency = options.concurrency || 1;
        this.jobs = [];
        this.active = 0;
        this.processors = new Map();
    }

    process(name, handler) {
        this.processors.set(name, handler);
    }

    add(name, data) {
        const job = { id: Date.now(), name, data, status: 'pending' };
        this.jobs.push(job);
        this.next();
        return job;
    }

    async next() {
        if (this.active >= this.concurrency || this.jobs.length === 0) return;

        const job = this.jobs.shift();
        const handler = this.processors.get(job.name);

        if (!handler) {
            console.error(\`No processor for job \${job.name}\`);
            return;
        }

        this.active++;
        job.status = 'processing';

        try {
            await handler(job);
            job.status = 'completed';
            this.emit('completed', job);
        } catch (err) {
            job.status = 'failed';
            job.error = err;
            this.emit('failed', job, err);
        } finally {
            this.active--;
            this.next();
        }
    }
}

module.exports = new Queue();`,
                metadata: { autoGenerated: true, pattern: 'queue' }
            })
        });

        // Logger Pattern
        this.patterns.set('logger', {
            className: 'Logger',
            description: 'Structured logging service',
            keywords: ['logger', 'log', 'winston', 'logging'],
            generate: () => ({
                path: 'src/utils/logger.js',
                language: 'javascript',
                lines: 45,
                code: `// Logger Utility
const winston = require('winston');

const logger = winston.createLogger({
    level: process.env.LOG_LEVEL || 'info',
    format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.json()
    ),
    transports: [
        new winston.transports.File({ filename: 'error.log', level: 'error' }),
        new winston.transports.File({ filename: 'combined.log' })
    ]
});

if (process.env.NODE_ENV !== 'production') {
    logger.add(new winston.transports.Console({
        format: winston.format.simple()
    }));
}

module.exports = logger;`,
                metadata: { autoGenerated: true, pattern: 'logger' }
            })
        });

        // Auth Middleware Pattern
        this.patterns.set('auth-middleware', {
            className: 'AuthMiddleware',
            description: 'JWT authentication middleware',
            keywords: ['auth', 'jwt', 'middleware', 'protect'],
            generate: () => ({
                path: 'src/middleware/auth.js',
                language: 'javascript',
                lines: 40,
                code: `// Auth Middleware
const jwt = require('jsonwebtoken');

const protect = async (req, res, next) => {
    let token;

    if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
        token = req.headers.authorization.split(' ')[1];
    }

    if (!token) {
        return res.status(401).json({ success: false, error: 'Not authorized to access this route' });
    }

    try {
        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        req.user = decoded;
        next();
    } catch (err) {
        return res.status(401).json({ success: false, error: 'Not authorized to access this route' });
    }
};

module.exports = protect;`,
                metadata: { autoGenerated: true, pattern: 'auth-middleware' }
            })
        });

        // Config Loader Pattern
        this.patterns.set('config', {
            className: 'Config',
            description: 'Configuration loader',
            keywords: ['config', 'configuration', 'env', 'settings'],
            generate: () => ({
                path: 'src/config/index.js',
                language: 'javascript',
                lines: 25,
                code: `// Configuration Loader
require('dotenv').config();

const config = {
    env: process.env.NODE_ENV || 'development',
    port: parseInt(process.env.PORT, 10) || 3000,
    db: {
        host: process.env.DB_HOST,
        port: parseInt(process.env.DB_PORT, 10) || 5432,
        name: process.env.DB_NAME,
    },
    jwt: {
        secret: process.env.JWT_SECRET,
        expire: process.env.JWT_EXPIRE || '30d'
    }
};

module.exports = config;`,
                metadata: { autoGenerated: true, pattern: 'config' }
            })
        });

        // Event Bus Pattern
        this.patterns.set('event-bus', {
            className: 'EventBus',
            description: 'Global event bus',
            keywords: ['event', 'bus', 'emitter', 'pubsub'],
            generate: () => ({
                path: 'src/lib/event-bus.js',
                language: 'javascript',
                lines: 20,
                code: `// Global Event Bus
const EventEmitter = require('events');

class EventBus extends EventEmitter {
    constructor() {
        super();
        if (!EventBus.instance) {
            EventBus.instance = this;
        }
        return EventBus.instance;
    }
}

const instance = new EventBus();
Object.freeze(instance);

module.exports = instance;`,
                metadata: { autoGenerated: true, pattern: 'event-bus' }
            })
        });

        // Email Service Pattern
        this.patterns.set('email-service', {
            className: 'EmailService',
            description: 'Email sending service',
            keywords: ['email', 'mail', 'smtp', 'nodemailer'],
            generate: () => ({
                path: 'src/services/email.service.js',
                language: 'javascript',
                lines: 45,
                code: `// Email Service
const nodemailer = require('nodemailer');

class EmailService {
    constructor() {
        this.transporter = nodemailer.createTransport({
            host: process.env.SMTP_HOST,
            port: process.env.SMTP_PORT,
            auth: {
                user: process.env.SMTP_EMAIL,
                pass: process.env.SMTP_PASSWORD
            }
        });
    }

    async sendEmail(options) {
        const message = {
            from: \`\${process.env.FROM_NAME} <\${process.env.FROM_EMAIL}>\`,
            to: options.email,
            subject: options.subject,
            text: options.message
        };

        const info = await this.transporter.sendMail(message);
        console.log('Message sent: %s', info.messageId);
        return info;
    }
}

module.exports = new EmailService();`,
                metadata: { autoGenerated: true, pattern: 'email-service' }
            })
        });
    },

    /**
     * Analyze code for dependencies
     */
    analyzeCode(code) {
        const dependencies = [];
        
        // Match require statements
        const requireRegex = /require\s*\(\s*['"]([^'"]+)['"]\s*\)/g;
        let match;
        
        while ((match = requireRegex.exec(code)) !== null) {
            const path = match[1];
            if (path.startsWith('./') || path.startsWith('../')) {
                dependencies.push({
                    type: 'require',
                    path: path,
                    isLocal: true
                });
            }
        }
        
        // Match ES6 imports
        const importRegex = /import\s+(?:{\s*[^}]+\s*}|\*\s+as\s+\w+|\w+)\s+from\s+['"]([^'"]+)['"]/g;
        
        while ((match = importRegex.exec(code)) !== null) {
            const path = match[1];
            if (path.startsWith('./') || path.startsWith('../')) {
                dependencies.push({
                    type: 'import',
                    path: path,
                    isLocal: true
                });
            }
        }
        
        return dependencies;
    },

    /**
     * Build dependency graph from artifacts
     */
    buildGraph(artifacts) {
        const nodes = [];
        const edges = [];
        const pathMap = new Map();
        
        // Create nodes
        artifacts.forEach(file => {
            const node = {
                id: this.normalizeId(file.path),
                label: this.getFileName(file.path),
                path: file.path,
                lines: file.lines,
                language: file.language,
                type: this.getNodeType(file.path),
                autoGenerated: file.metadata?.autoGenerated || false
            };
            nodes.push(node);
            pathMap.set(node.id, node);
            pathMap.set(file.path, node);
        });
        
        // Create edges
        artifacts.forEach(file => {
            const deps = this.analyzeCode(file.code);
            const sourceId = this.normalizeId(file.path);
            
            deps.forEach(dep => {
                const targetId = this.resolveDepPath(file.path, dep.path);
                const targetExists = nodes.some(n => n.id === targetId);
                
                edges.push({
                    source: sourceId,
                    target: targetId,
                    exists: targetExists,
                    type: dep.type
                });
            });
        });
        
        return { nodes, edges };
    },

    /**
     * Find missing dependencies
     */
    findMissing(graph) {
        const missing = [];
        const seen = new Set();
        
        graph.edges.forEach(edge => {
            if (!edge.exists && !seen.has(edge.target)) {
                seen.add(edge.target);
                
                // CHECK: Skip if already in artifacts
                const alreadyGenerated = graph.nodes.some(n => 
                    n.id.includes(edge.target) || 
                    edge.target.includes(n.id)
                );
                
                if (alreadyGenerated) {
                    return; // Skip this one
                }
                
                const sourceNode = graph.nodes.find(n => n.id === edge.source);
                const pattern = this.identifyPattern(edge.target);
                
                missing.push({
                    requiredBy: sourceNode?.path || edge.source,
                    missingId: edge.target,
                    pattern: pattern,
                    canGenerate: !!pattern
                });
            }
        });
        
        return missing;
    },

    /**
     * Identify pattern from path/filename
     */
    identifyPattern(pathOrId) {
        const normalized = pathOrId.toLowerCase();
        
        for (const [patternName, config] of this.patterns.entries()) {
            // Check if any keyword matches
            if (config.keywords.some(kw => normalized.includes(kw))) {
                return patternName;
            }
            
            // Check class name
            if (normalized.includes(config.className.toLowerCase())) {
                return patternName;
            }
        }
        
        return null;
    },

    /**
     * Auto-generate missing dependencies
     */
    autoGenerate(missing) {
        const generated = [];
        
        missing.forEach(dep => {
            if (!dep.canGenerate || !dep.pattern) {
                // Smart Fallback (Option B)
                const filename = this.getFileName(dep.missingId);
                const className = filename.split('.')[0].split('-').map(p => p.charAt(0).toUpperCase() + p.slice(1)).join('');
                
                generated.push({
                    path: dep.missingId.endsWith('.js') ? dep.missingId : `${dep.missingId}.js`,
                    language: 'javascript',
                    lines: 20,
                    code: `// Auto-generated stub for ${filename}
class ${className} {
    constructor() {
        console.log('${className} initialized');
    }
}
module.exports = new ${className}();`,
                    metadata: { autoGenerated: true, pattern: 'fallback', description: 'Auto-generated stub' }
                });
                return;
            }
            
            const config = this.patterns.get(dep.pattern);
            if (!config) return;
            
            const artifact = config.generate();
            
            // Adjust path to match expected location if needed
            const targetDir = this.getDirectory(dep.requiredBy);
            const expectedPath = this.adjustPath(artifact.path, targetDir, dep.missingId);
            
            generated.push({
                ...artifact,
                path: expectedPath,
                metadata: {
                    ...artifact.metadata,
                    requiredBy: dep.requiredBy,
                    originalPattern: dep.pattern,
                    description: config.description
                }
            });
        });
        
        return generated;
    },

    // Helper methods
    normalizeId(path) {
        return path.replace(/^src\//, '').replace(/\.js$/, '');
    },

    getFileName(path) {
        return path.split('/').pop();
    },

    getDirectory(path) {
        const parts = path.split('/');
        parts.pop();
        return parts.join('/') || 'src';
    },

    getNodeType(path) {
        if (path.includes('server')) return 'server';
        if (path.includes('route') || path.includes('api')) return 'route';
        if (path.includes('controller')) return 'controller';
        if (path.includes('model')) return 'model';
        if (path.includes('middleware')) return 'middleware';
        if (path.includes('handler')) return 'handler';
        return 'module';
    },

    resolveDepPath(fromPath, depPath) {
        // Simple resolution - just normalize the dependency path
        const cleanDep = depPath.replace(/^\.\//, '').replace(/^\.\.\//, '').replace(/\.js$/, '');
        return cleanDep;
    },

    adjustPath(generatedPath, targetDir, missingId) {
        // Try to use the generated path's filename in the target directory
        const filename = this.getFileName(generatedPath);
        return `${targetDir}/${filename}`;
    },

    /**
     * Render dependency graph as SVG
     */
    renderGraph(graph, containerId) {
        const container = document.getElementById(containerId);
        if (!container) {
            console.warn(`[DependencyEngine] Container ${containerId} not found`);
            return;
        }
        
        // Use existing DependencyUtils visualization if available
        if (typeof DependencyUtils !== 'undefined' && DependencyUtils.generateVisualization) {
            const graphData = {};
            graph.nodes.forEach(node => {
                const deps = graph.edges
                    .filter(e => e.source === node.id)
                    .map(e => e.target);
                graphData[node.path] = deps;
            });
            
            const viz = DependencyUtils.generateVisualization(graphData);
            container.innerHTML = this.createSVGFromViz(viz, graph);
        } else {
            // Fallback simple rendering
            container.innerHTML = this.createSimpleGraph(graph);
        }
    },

    createSimpleGraph(graph) {
        return `
            <div style="padding: 1rem; background: var(--bg-secondary); border-radius: 8px;">
                <div style="margin-bottom: 1rem;">
                    <strong>Dependency Graph:</strong> ${graph.nodes.length} files, ${graph.edges.length} dependencies
                </div>
                <div style="display: grid; gap: 0.5rem;">
                    ${graph.nodes.map(node => `
                        <div style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; background: var(--bg-tertiary); border-radius: 4px;">
                            <div style="width: 8px; height: 8px; border-radius: 50%; background: ${node.autoGenerated ? 'var(--accent-green)' : 'var(--accent-blue)'}"></div>
                            <div style="flex: 1;">
                                <div style="font-family: monospace; font-size: 0.9rem;">${node.label}</div>
                                <div style="font-size: 0.75rem; color: var(--text-secondary);">${node.type} â€¢ ${node.lines} lines</div>
                            </div>
                        </div>
                    `).join('')}
                </div>
                <div style="margin-top: 1rem; display: flex; gap: 1rem; font-size: 0.85rem; color: var(--text-secondary);">
                    <div style="display: flex; align-items: center; gap: 0.25rem;">
                        <div style="width: 8px; height: 8px; border-radius: 50%; background: var(--accent-blue)"></div>
                        Generated
                    </div>
                    <div style="display: flex; align-items: center; gap: 0.25rem;">
                        <div style="width: 8px; height: 8px; border-radius: 50%; background: var(--accent-green)"></div>
                        Auto-generated
                    </div>
                </div>
            </div>
        `;
    },

    createSVGFromViz(viz, graph) {
        // Enhanced SVG rendering using viz data
        let svg = '<svg width="100%" height="400" style="background: var(--bg-primary)">';
        
        // Draw edges
        viz.edges.forEach(edge => {
            const sourceNode = viz.nodes.find(n => n.id === edge.source);
            const targetNode = viz.nodes.find(n => n.id === edge.target);
            
            if (sourceNode && targetNode) {
                const edgeData = graph.edges.find(e => 
                    e.source === this.normalizeId(edge.source) && 
                    e.target === this.normalizeId(edge.target)
                );
                
                const strokeColor = edgeData?.exists ? 'var(--border-color)' : 'var(--accent-red)';
                const strokeDash = edgeData?.exists ? '0' : '5,5';
                
                svg += `<line x1="${sourceNode.x}" y1="${sourceNode.y}" x2="${targetNode.x}" y2="${targetNode.y}" stroke="${strokeColor}" stroke-width="2" stroke-dasharray="${strokeDash}"/>`;
            }
        });
        
        // Draw nodes
        viz.nodes.forEach(node => {
            const nodeData = graph.nodes.find(n => n.id === this.normalizeId(node.id));
            const color = nodeData?.autoGenerated ? 'var(--accent-green)' : 'var(--accent-blue)';
            
            svg += `
                <circle cx="${node.x}" cy="${node.y}" r="40" fill="${color}" opacity="0.2" stroke="${color}" stroke-width="2"/>
                <text x="${node.x}" y="${node.y + 55}" text-anchor="middle" fill="var(--text-primary)" font-size="12">${node.label}</text>
            `;
        });
        
        svg += '</svg>';
        return svg;
    }
};

// Expose to window
if (typeof window !== 'undefined') {
    window.DependencyEngine = DependencyEngine;
}

// Initialize on load
if (typeof window !== 'undefined') {
    window.addEventListener('DOMContentLoaded', () => {
        DependencyEngine.init();
    });
}